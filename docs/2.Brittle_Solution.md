## DsPy solution to Brittle Prompt Engineering

**DSPy's Solution:** Declarative Signatures & Compilation

Instead of writing fragile prompts, you declare the `intent` of each step. The DSPy compiler then generates and optimizes the actual prompts for you.

### Comparing Prompt Engineering Vs DsPy

**Scenario** : Classify sentiment of a sentence

**Prompt Engineering Approach:**
- Refer to [traditional_main.py](../traditional/1.main.py)
- The prompt would be passed to a LLM and answer is fetched accordingly.


**DsPy Declarative Approach:**
- Refer to [dspy_main.py](../dspy/1.main.py)

#### DsPy Solution Explanation:

- You **declare** `what you want` ("text" & "sentiment"), `not how the model` should achieve it. The compiler automatically generates and tests different instructional phrasings to find what works best systematically.
- you can view the prompt by logging into `mlflow` and check the latest trace.
- **Output fields** can have structured descriptions and types. More importantly, DSPy modules handle the parsing internally.

**Scenario** : Analyze a business opportunity by conducting market research, customer analysis, and generating strategic recommendations

**Prompt Engineering Approach:**

- Refer to [traditional_multi.py](../traditional/2.multi.py)

**DsPy Declarative Approach:**

- Refer to [dspy_multi.py](../dspy/2.multi.py)

#### Solutions and Approach:

- This is `composable, testable code` - not string concatenation. Changing one module doesn't break others because the interfaces are well-defined.
- You can version control your program.
- **The Core Shift:** You're no longer engineering prompts; you're engineering a program that gets compiled into optimized prompts.